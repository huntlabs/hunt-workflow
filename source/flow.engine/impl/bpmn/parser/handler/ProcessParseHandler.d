/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
module flow.engine.impl.bpmn.parser.handler.ProcessParseHandler;

import hunt.collection.List;

import flow.bpmn.model.BaseElement;
import flow.bpmn.model.BpmnModel;
import flow.bpmn.model.EventListener;
import flow.bpmn.model.ImplementationType;
import flow.bpmn.model.Process;
import flow.common.api.deleg.event.FlowableEngineEventType;
import flow.common.event.FlowableEventSupport;
import flow.engine.impl.bpmn.parser.BpmnParse;
import flow.engine.impl.persistence.entity.ProcessDefinitionEntity;
import flow.engine.impl.util.CommandContextUtil;
import flow.engine.impl.bpmn.parser.handler.AbstractBpmnParseHandler;
import hunt.logging;
import flow.common.api.deleg.event.FlowableEventType;
/**
 * @author Joram Barrez
 */
class ProcessParseHandler : AbstractBpmnParseHandler!Process {

    public static  string PROPERTYNAME_DOCUMENTATION = "documentation";

    override
    BaseElement getHandledType() {
        return new Process;
    }

    override
    protected void executeParse(BpmnParse bpmnParse, Process process) {
        if (!process.isExecutable()) {
            logInfo("Ignoring non-executable process with id='{%s}'. Set the attribute isExecutable=\"true\" to deploy this process.", process.getId());
        } else {
            bpmnParse.getProcessDefinitions().add(transformProcess(bpmnParse, process));
        }
    }

    protected ProcessDefinitionEntity transformProcess(BpmnParse bpmnParse, Process process) {
        ProcessDefinitionEntity currentProcessDefinition = CommandContextUtil.getProcessDefinitionEntityManager().create();
        bpmnParse.setCurrentProcessDefinition(currentProcessDefinition);

        /*
         * Mapping object model - bpmn xml: processDefinition.id -> generated by activiti engine processDefinition.key -> bpmn id (required) processDefinition.name -> bpmn name (optional)
         */
        currentProcessDefinition.setKey(process.getId());
        currentProcessDefinition.setName(process.getName());
        currentProcessDefinition.setCategory(bpmnParse.getBpmnModel().getTargetNamespace());
        currentProcessDefinition.setDescription(process.getDocumentation());
        currentProcessDefinition.setDeploymentId(bpmnParse.getDeployment().getId());

        if (bpmnParse.getDeployment().getEngineVersion() !is null) {
            currentProcessDefinition.setEngineVersion(bpmnParse.getDeployment().getEngineVersion());
        }

        createEventListeners(bpmnParse, process.getEventListeners());

        //if (LOGGER.isDebugEnabled()) {
        //    LOGGER.debug("Parsing process {}", currentProcessDefinition.getKey());
        //}

        bpmnParse.processFlowElements(process.getFlowElements());
        processArtifacts(bpmnParse, process.getArtifacts());

        return currentProcessDefinition;
    }

    protected void createEventListeners(BpmnParse bpmnParse, List!EventListener eventListeners) {

        if (eventListeners !is null && !eventListeners.isEmpty()) {
            foreach (EventListener eventListener ; eventListeners) {
                // Extract specific event-types (if any)
                FlowableEngineEventType[] types = FlowableEngineEventType.getTypesFromString(eventListener.getEvents());
                FlowableEventType [] castTypes;
                foreach(FlowableEngineEventType t ; types)
                {
                  castTypes ~= cast(FlowableEventType)t;
                }

                if (ImplementationType.IMPLEMENTATION_TYPE_CLASS == (eventListener.getImplementationType())) {

                    getEventSupport(bpmnParse.getBpmnModel()).addEventListener(bpmnParse.getListenerFactory().createClassDelegateEventListener(eventListener), castTypes);

                } else if (ImplementationType.IMPLEMENTATION_TYPE_DELEGATEEXPRESSION == (eventListener.getImplementationType())) {
                    getEventSupport(bpmnParse.getBpmnModel()).addEventListener(bpmnParse.getListenerFactory().createDelegateExpressionEventListener(eventListener), castTypes);

                } else if (ImplementationType.IMPLEMENTATION_TYPE_THROW_SIGNAL_EVENT == (eventListener.getImplementationType())
                        || ImplementationType.IMPLEMENTATION_TYPE_THROW_GLOBAL_SIGNAL_EVENT == (eventListener.getImplementationType())
                        || ImplementationType.IMPLEMENTATION_TYPE_THROW_MESSAGE_EVENT == (eventListener.getImplementationType())
                        || ImplementationType.IMPLEMENTATION_TYPE_THROW_ERROR_EVENT == (eventListener.getImplementationType())) {

                    getEventSupport(bpmnParse.getBpmnModel()).addEventListener(bpmnParse.getListenerFactory().createEventThrowingEventListener(eventListener), castTypes);

                } else {
                    logWarning("Unsupported implementation type for EventListener: {%s} for element {%s}", eventListener.getImplementationType(), bpmnParse.getCurrentFlowElement().getId());
                }
            }
        }

    }

    protected FlowableEventSupport getEventSupport(BpmnModel bpmnModel) {
        return cast(FlowableEventSupport) bpmnModel.getEventSupport();
    }

}
